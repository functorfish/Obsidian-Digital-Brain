/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, visit the plugin's github repository
*/

'use strict';

var state = require('@codemirror/state');
var obsidian = require('obsidian');
var view = require('@codemirror/view');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const TOKEN_NAMES = {
    sceneHeading: "scene-heading",
    action: "action",
    character: "character",
    dialogue: "dialogue",
    parenthetical: "parenthetical",
    lyrics: "lyrics",
    centered: "centered",
    transition: "transition",
    section: "section",
    synopsis: "synopsis",
    boneyard: "boneyard",
    fBoneyardStart: "formatting-boneyard-start",
    fBoneyardEnd: "formatting-boneyard-end",
    pageBreak: "page-break",
};
const n = TOKEN_NAMES;
// transparency: this list is enhanced and generated by ChatGPT
const sceneHeadingPrefixesMap = {
    // - Latin: INT, EXT, EST, I/E, INT/EXT
    latin: ["int", "ext", "est", "i/e", "int/ext"],
    // - Russian: ИНТ, НАТ, ЭСТ, И/Н, ИНТ/НАТ
    russian: ["инт", "нат", "эст", "и/н", "инт/нат"],
    // - Ukrainian: ІНТ, НАТ, ЕСТ, І/Н, ІНТ/НАТ
    ukrainian: ["інт", "нат", "ест", "і/н", "інт/нат"],
    // - Bulgarian: ВН, ИЗН, ВН/ИЗН
    bulgarian: ["вн", "изн", "вн/изн"],
    // - Serbian/Macedonian: ВН, НАДВ, ВН/НАДВ
    serbianMacedonian: ["вн", "надв", "вн/надв"],
    // - Greek: ΕΣΩ. (INT), ΕΞΩ. (EXT), ΕΣΩ/ΕΞΩ. (INT/EXT)
    //   Sometimes ΕΣΤ. for "establishing"
    greek: ["εσω", "εξω", "εσω/εξω", "εστ"],
    // - Hebrew: פנ. (INT = פנימי), חוץ. (EXT), פנ/חוץ. (INT/EXT)
    //   NB: Hebrew is RTL but regex still matches left-to-right in source
    hebrew: ["פנ", "חוץ", "פנ/חוץ"],
    // - Arabic: د. (داخل = INT), خ. (خارج = EXT), د/خ. (INT/EXT)
    //   Sometimes spelled in full: داخل, خارج
    arabic: ["د", "خ", "د/خ", "داخل", "خارج", "داخل/خارج"],
    // - Turkish: İÇ (INT), DIŞ (EXT), İÇ/DIŞ
    turkish: ["iç", "dış", "iç/dış"],
    // - French/Spanish/Italian (they often keep English, but some use native)
    //   French: INTÉR. / EXT. ; Spanish: INT. / EXT. ; Italian: INT. / EST.
    //   Adding common alternatives
    romance: ["intér", "inter", "est", "ext"],
};
const dedupedSceneHeadingPrefixes = [
    ...new Set(Object.values(sceneHeadingPrefixesMap).flat()),
];
const LINE_TOKENS = [
    {
        id: n.sceneHeading,
        // - Scene heading int/ext
        // - Fountain Power User: dot prefix e.g. `.MONTAGE`
        regex: new RegExp(`^((?:\\*{0,3}_?)?(?:${dedupedSceneHeadingPrefixes.join("|")})[. ].+)|^\\.(?!\\.+)(.+)`, "iu"),
    },
    {
        id: n.action,
        // Fountain Power User: lines starting with `!`
        regex: /^!.*$/u,
    },
    {
        id: n.character,
        // - Latin uppercase
        // - Extended Latin (À-ß, etc.)
        // - Cyrillic uppercase (0400–052F)
        // Fountain Power User: `@`-prefix, e.g. `@O'McDONALD`
        regex: /^[^\S\r\n]*(?=.*[\p{Lu}\u0400-\u04FF\u0500-\u052F])[A-Z\d\u00C0-\u00DEF\u0400-\u04FF\u0500-\u052F \t'.-]+\s?(\(.*\))?$|@.*$/u,
    },
    {
        id: n.dialogue,
        // Dialogue must follow a character line
        regex: /^[^\S\r\n]*(\^?)?\n(?!\n+)([\s\S]+)/u,
    },
    {
        id: n.parenthetical,
        // e.g. `(whispering)`
        regex: /^[^\S\r\n]*(\(.+\))$/u,
    },
    {
        id: n.lyrics,
        // Lines starting with ~
        regex: /^~.*$/u,
    },
    {
        id: n.centered,
        // > CENTERED TEXT <
        regex: /^[^\S\r\n]*>[^<>]+<$/u,
    },
    {
        id: n.transition,
        // - Lines ending with `TO:`, e.g. `CUT TO:`
        // - Fountain Power user: `>`-prefix, e.g. `FADE TO BLACK:`
        // - Cyrillic uppercase `TO:`, e.g. `перейти к TO:`
        regex: /^[^\S\r\n]*(>[^<\n\r]*|[\p{Lu}\u00C0-\u024F\u0370-\u03FF\u0400-\u052F\u0590-\u05FF\u0600-\u06FF ]+ TO[:：])$/u,
    },
    {
        id: n.section,
        // e.g. `### SECTION TITLE`
        regex: /^(#+) *(.*)/u,
    },
    {
        id: n.synopsis,
        // `= Synopsis`
        regex: /^=(?!=+) *(.*)$/u,
    },
    // Note: /^(?:\[{2}(?!\[+))(.+)(?:\]{2}(?!\[+))$/,
    // note_inline: /(?:\[{2}(?!\[+))([\s\S]+?)(?:\]{2}(?!\[+))/g,
    // boneyard: /(^\/\*|^\*\/)$/g,
    {
        id: n.fBoneyardStart,
        // `/* boneyard start`
        regex: /(^\/\*$)/u,
    },
    {
        id: n.fBoneyardEnd,
        // `*/ boneyard end`
        regex: /(^\*\/$)/u,
    },
    {
        id: n.pageBreak,
        // === (3 or more)
        regex: /^={3,}$/u,
    },
];

function composeFntClass(t) {
    return `cm-formatting cm-fountain-formatting-${t}`;
}
function handleEmptyLine(line, state) {
    if (line.trim()) {
        return false;
    }
    // At least two spaces to be considered
    // https://fountain.io/syntax#line-breaks
    if (line.length < 2) {
        state.inDialogue = false;
    }
    return true;
}
/** Skip formatting within %% comments */
function handleCommentBlock(line, state) {
    if (state.inCommentBlock) {
        if (line.includes("%%")) {
            state.inCommentBlock = false;
        }
        return true;
    }
    if (line.includes("%%")) {
        state.inCommentBlock = true;
        return true;
    }
    return false;
}
function handleToken(tId, state, context) {
    if (tId === TOKEN_NAMES.fBoneyardEnd) {
        state.inBoneyard = false;
    }
    if (state.inBoneyard) {
        return TOKEN_NAMES.boneyard;
    }
    if (tId === TOKEN_NAMES.fBoneyardStart) {
        state.inDialogue = false;
        state.inBoneyard = true;
    }
    if (tId === TOKEN_NAMES.character) {
        if (context.afterEmptyLine &&
            !context.beforeEmptyLine &&
            !context.isLastLine) {
            state.inDialogue = true;
        }
        else {
            return null;
        }
    }
    if (tId === TOKEN_NAMES.parenthetical && !state.inDialogue) {
        return null;
    }
    if (tId === TOKEN_NAMES.transition &&
        !(context.afterEmptyLine && context.beforeEmptyLine)) {
        return null;
    }
    return tId;
}
function getLineFormat(line, state, context, settings) {
    if (handleEmptyLine(line, state)) {
        return null;
    }
    if (handleCommentBlock(line, state)) {
        return null;
    }
    for (const { id: tId, regex: tRegex } of LINE_TOKENS) {
        if (tRegex.test(line)) {
            const token = handleToken(tId, state, context);
            // setting to early exit on transition-blockquotes
            if (settings.preferObsidianBlockquote &&
                token === TOKEN_NAMES.transition &&
                line.startsWith(">")) {
                return null;
            }
            if (token !== null) {
                return token;
            }
        }
    }
    if (state.inDialogue) {
        return TOKEN_NAMES.dialogue;
    }
    if (state.inBoneyard) {
        return TOKEN_NAMES.boneyard;
    }
    if (line.startsWith(">"))
        return null;
    return TOKEN_NAMES.action;
}
function buildDecorations(view$1, isFountainStateField, settings) {
    const isFountain = view$1.state.field(isFountainStateField, false);
    if (!isFountain) {
        return view.Decoration.none;
    }
    const builder = new state.RangeSetBuilder();
    function markDeco(start, end, className) {
        const deco = view.Decoration.mark({ class: className });
        builder.add(start, end, deco);
    }
    const state$1 = {
        inDialogue: false,
        inBoneyard: false,
        inCommentBlock: false,
    };
    for (const { from, to } of view$1.visibleRanges) {
        const visibleText = view$1.state.sliceDoc(from, to);
        const maxLines = view$1.state.doc.lines;
        for (let pos = from; pos <= to;) {
            const line = view$1.state.doc.lineAt(pos);
            const { from: lFrom, to: lTo, text: lText } = line;
            const relativeFrom = lFrom - from;
            const relativeTo = lTo - from;
            const context = {
                afterEmptyLine: visibleText[relativeFrom - 2] === "\n",
                beforeEmptyLine: visibleText[relativeTo + 1] === "\n",
                isLastLine: line.number === maxLines,
            };
            const token = getLineFormat(lText, state$1, context, settings);
            if (!token) {
                pos = lTo + 1;
                continue;
            }
            const deco = view.Decoration.line({ class: "cm-fountain-" + token });
            builder.add(lFrom, lFrom, deco);
            // Mark Decorations
            const firstChar = lText[0];
            const lastChar = lText[line.length - 1];
            // action
            if (token === TOKEN_NAMES.action && firstChar === "!" && !lText.startsWith("![[")) {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // scene heading
            if (token === TOKEN_NAMES.sceneHeading && firstChar === ".") {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // lyric
            if (token === TOKEN_NAMES.lyrics && firstChar === "~") {
                markDeco(lFrom, lFrom + 1, composeFntClass(token));
            }
            // synopsis
            if (token === TOKEN_NAMES.synopsis && firstChar === "=") {
                markDeco(lFrom, lFrom + 2, composeFntClass(token));
            }
            // character
            if (token === TOKEN_NAMES.character) {
                // forced character
                if (firstChar === "@") {
                    markDeco(lFrom, lFrom + 1, composeFntClass(token));
                }
                // character extension
                if (lastChar === ")") {
                    const charExtension = lText.match(/(\(.*\))?$/g);
                    if (charExtension === null) {
                        console.error("Character regex broken; char ext segment should exist");
                        continue;
                    }
                    const charExtensionLength = charExtension[0].length;
                    const charExtensionStart = lTo - charExtensionLength;
                    markDeco(charExtensionStart, lTo, "cm-fountain-character-extension");
                }
            }
            // centered
            if (token === TOKEN_NAMES.centered && lastChar === "<") {
                markDeco(lTo - 1, lTo, composeFntClass(token));
            }
            pos = lTo + 1;
        }
    }
    return builder.finish();
}

/* ------------------------------------ - ----------------------------------- */
const updateIsFountainState = state.StateEffect.define();
const isFountainStateField = state.StateField.define({
    create() {
        return false;
    },
    update(value, tr) {
        for (const effect of tr.effects) {
            if (effect.is(updateIsFountainState)) {
                return effect.value;
            }
        }
        return value;
    },
});
function updateFileState({ app, hasTag }) {
    const markdownView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    if (!markdownView || !("cm" in markdownView.editor))
        return;
    const cmEditor = markdownView.editor.cm;
    cmEditor.dispatch({ effects: updateIsFountainState.of(hasTag) });
}
/* ------------------------------------ - ----------------------------------- */
let FountainPlugin$1 = class FountainPlugin {
    constructor(view$1, settings) {
        this.settings = settings;
        this.decorations = view$1.state.field(isFountainStateField)
            ? buildDecorations(view$1, isFountainStateField, settings)
            : view.Decoration.none;
    }
    update(update) {
        const shouldBuildDecorations = update.docChanged ||
            update.viewportChanged ||
            update.startState.field(isFountainStateField) !==
                update.state.field(isFountainStateField);
        if (shouldBuildDecorations) {
            this.decorations = buildDecorations(update.view, isFountainStateField, this.settings);
        }
    }
};
function fountainPlugin(settings) {
    const plugin = view.ViewPlugin.fromClass(class extends FountainPlugin$1 {
        constructor(view) {
            super(view, settings);
        }
    }, { decorations: (value) => value.decorations });
    return [isFountainStateField, plugin];
}

const DEFAULT_SETTINGS = {
    fixMinimal: false,
    preferObsidianBlockquote: false,
};
const themeFixClass = "fountain-theme-fix";
const setFixThemeState = {
    add() {
        document.body.classList.add(themeFixClass);
    },
    remove() {
        document.body.classList.remove(themeFixClass);
    },
};
class FountainEditorSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: "Fountain Editor Settings" });
        new obsidian.Setting(containerEl)
            .setName("Fix broken styling on certain themes")
            .setDesc("Fix Fountain formatting on themes like Minimal.")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.fixMinimal)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.fixMinimal = value;
            yield this.plugin.saveSettings();
            // Add or remove the class
            if (value) {
                setFixThemeState.add();
            }
            else {
                setFixThemeState.remove();
            }
        })));
        new obsidian.Setting(containerEl)
            .setName("Prefer Obsidian's blockquote over Fountain's forced Transition")
            .setDesc("Skips trying to convert single-lines that start with `>` from Obsidian blockquotes into Fountain's Transitions. Blockquotes are the preferred cleaner way to annotate your screenplay, but you will need to strip them out before rendering your Fountain document to PDF.")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.preferObsidianBlockquote)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.preferObsidianBlockquote = value;
            yield this.plugin.saveSettings();
        })));
    }
}

function onMetadataChanged(app, file) {
    const activeFile = getActiveMarkdownFile(app);
    if (activeFile && activeFile.path === file.path) {
        updateClass(app);
    }
}
function updateClass(app) {
    var _a, _b;
    const file = getActiveMarkdownFile(app);
    if (!file) {
        toggleClass(app, false);
        return;
    }
    if (file.extension === "fountain" || file.basename.endsWith(".fountain")) {
        toggleClass(app, true);
        return;
    }
    const metadata = app.metadataCache.getFileCache(file);
    if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.frontmatter) === null || _a === void 0 ? void 0 : _a.tags) {
        const tags = metadata.frontmatter.tags;
        if (tags.includes("fountain")) {
            toggleClass(app, true);
            return;
        }
    }
    if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.frontmatter) === null || _b === void 0 ? void 0 : _b.cssclasses) {
        const cssclasses = metadata.frontmatter.cssclasses;
        if (cssclasses.includes("fountain")) {
            toggleClass(app, true);
            return;
        }
    }
    toggleClass(app, false);
}
function toggleClass(app, add) {
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    const sourceView = view === null || view === void 0 ? void 0 : view.containerEl.querySelector(".markdown-source-view");
    updateFileState({ app, hasTag: add });
    if (!sourceView)
        return;
    sourceView.classList.toggle("fountain", add);
}
function getActiveMarkdownFile(app) {
    var _a;
    const view = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    return (_a = view === null || view === void 0 ? void 0 : view.file) !== null && _a !== void 0 ? _a : undefined;
}

new state.Compartment();
class FountainPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            /* ---------------------------- settings -------------------------------- */
            yield this.loadSettings();
            this.addSettingTab(new FountainEditorSettingTab(this.app, this));
            // Apply the classname on load if the setting is enabled
            if (this.settings.fixMinimal) {
                setFixThemeState.add();
            }
            /* ------------------------ editor extension ---------------------------- */
            // this.registerEditorExtension(fountainPlugin);
            this.registerEditorExtension(fountainPlugin(this.settings));
            // Ensure `fountain` class is added to relevant leaves
            this.app.workspace.on("active-leaf-change", () => {
                updateClass(this.app);
            });
            this.app.workspace.on("file-open", () => {
                updateClass(this.app);
            });
            this.app.metadataCache.on("changed", (file) => {
                onMetadataChanged(this.app, file);
            });
            updateClass(this.app);
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, (yield this.loadData()));
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    onunload() {
        this.app.metadataCache.off("changed", (file) => {
            onMetadataChanged(this.app, file);
        });
        updateClass(this.app);
        // Remove the classname when the plugin is unloaded
        setFixThemeState.remove();
    }
}

module.exports = FountainPlugin;


/* nosourcemap */